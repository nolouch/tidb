// Copyright 2025 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v5.29.3
// source: proto/v1/systemtable.proto

package stmtsummaryv3proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SystemTablePushService_PushStatements_FullMethodName = "/systemtable.v1.SystemTablePushService/PushStatements"
	SystemTablePushService_PushTableRows_FullMethodName  = "/systemtable.v1.SystemTablePushService/PushTableRows"
	SystemTablePushService_Ping_FullMethodName           = "/systemtable.v1.SystemTablePushService/Ping"
)

// SystemTablePushServiceClient is the client API for SystemTablePushService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SystemTablePushServiceClient interface {
	// Push optimized statement batch (high performance)
	PushStatements(ctx context.Context, in *StatementBatch, opts ...grpc.CallOption) (*PushResponse, error)
	// Push generic table rows (flexible for any table)
	PushTableRows(ctx context.Context, in *TableRowBatch, opts ...grpc.CallOption) (*PushResponse, error)
	// Health check and capability discovery
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
}

type systemTablePushServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemTablePushServiceClient(cc grpc.ClientConnInterface) SystemTablePushServiceClient {
	return &systemTablePushServiceClient{cc}
}

func (c *systemTablePushServiceClient) PushStatements(ctx context.Context, in *StatementBatch, opts ...grpc.CallOption) (*PushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, SystemTablePushService_PushStatements_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemTablePushServiceClient) PushTableRows(ctx context.Context, in *TableRowBatch, opts ...grpc.CallOption) (*PushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, SystemTablePushService_PushTableRows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemTablePushServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, SystemTablePushService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemTablePushServiceServer is the server API for SystemTablePushService service.
// All implementations must embed UnimplementedSystemTablePushServiceServer
// for forward compatibility.
type SystemTablePushServiceServer interface {
	// Push optimized statement batch (high performance)
	PushStatements(context.Context, *StatementBatch) (*PushResponse, error)
	// Push generic table rows (flexible for any table)
	PushTableRows(context.Context, *TableRowBatch) (*PushResponse, error)
	// Health check and capability discovery
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	mustEmbedUnimplementedSystemTablePushServiceServer()
}

// UnimplementedSystemTablePushServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSystemTablePushServiceServer struct{}

func (UnimplementedSystemTablePushServiceServer) PushStatements(context.Context, *StatementBatch) (*PushResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PushStatements not implemented")
}
func (UnimplementedSystemTablePushServiceServer) PushTableRows(context.Context, *TableRowBatch) (*PushResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PushTableRows not implemented")
}
func (UnimplementedSystemTablePushServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedSystemTablePushServiceServer) mustEmbedUnimplementedSystemTablePushServiceServer() {
}
func (UnimplementedSystemTablePushServiceServer) testEmbeddedByValue() {}

// UnsafeSystemTablePushServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemTablePushServiceServer will
// result in compilation errors.
type UnsafeSystemTablePushServiceServer interface {
	mustEmbedUnimplementedSystemTablePushServiceServer()
}

func RegisterSystemTablePushServiceServer(s grpc.ServiceRegistrar, srv SystemTablePushServiceServer) {
	// If the following call panics, it indicates UnimplementedSystemTablePushServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SystemTablePushService_ServiceDesc, srv)
}

func _SystemTablePushService_PushStatements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemTablePushServiceServer).PushStatements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemTablePushService_PushStatements_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemTablePushServiceServer).PushStatements(ctx, req.(*StatementBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemTablePushService_PushTableRows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableRowBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemTablePushServiceServer).PushTableRows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemTablePushService_PushTableRows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemTablePushServiceServer).PushTableRows(ctx, req.(*TableRowBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemTablePushService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemTablePushServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemTablePushService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemTablePushServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemTablePushService_ServiceDesc is the grpc.ServiceDesc for SystemTablePushService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemTablePushService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "systemtable.v1.SystemTablePushService",
	HandlerType: (*SystemTablePushServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushStatements",
			Handler:    _SystemTablePushService_PushStatements_Handler,
		},
		{
			MethodName: "PushTableRows",
			Handler:    _SystemTablePushService_PushTableRows_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _SystemTablePushService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/v1/systemtable.proto",
}

const (
	SystemTablePullService_QueryTable_FullMethodName    = "/systemtable.v1.SystemTablePullService/QueryTable"
	SystemTablePullService_ListTables_FullMethodName    = "/systemtable.v1.SystemTablePullService/ListTables"
	SystemTablePullService_DescribeTable_FullMethodName = "/systemtable.v1.SystemTablePullService/DescribeTable"
)

// SystemTablePullServiceClient is the client API for SystemTablePullService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SystemTablePullServiceClient interface {
	// Query any table with SQL-like syntax (schema-agnostic!)
	QueryTable(ctx context.Context, in *TableQuery, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TableQueryResponse], error)
	// Discover available tables
	ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (*ListTablesResponse, error)
	// Get table schema (for tools/debugging)
	DescribeTable(ctx context.Context, in *DescribeTableRequest, opts ...grpc.CallOption) (*DescribeTableResponse, error)
}

type systemTablePullServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemTablePullServiceClient(cc grpc.ClientConnInterface) SystemTablePullServiceClient {
	return &systemTablePullServiceClient{cc}
}

func (c *systemTablePullServiceClient) QueryTable(ctx context.Context, in *TableQuery, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TableQueryResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SystemTablePullService_ServiceDesc.Streams[0], SystemTablePullService_QueryTable_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TableQuery, TableQueryResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SystemTablePullService_QueryTableClient = grpc.ServerStreamingClient[TableQueryResponse]

func (c *systemTablePullServiceClient) ListTables(ctx context.Context, in *ListTablesRequest, opts ...grpc.CallOption) (*ListTablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTablesResponse)
	err := c.cc.Invoke(ctx, SystemTablePullService_ListTables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemTablePullServiceClient) DescribeTable(ctx context.Context, in *DescribeTableRequest, opts ...grpc.CallOption) (*DescribeTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeTableResponse)
	err := c.cc.Invoke(ctx, SystemTablePullService_DescribeTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemTablePullServiceServer is the server API for SystemTablePullService service.
// All implementations must embed UnimplementedSystemTablePullServiceServer
// for forward compatibility.
type SystemTablePullServiceServer interface {
	// Query any table with SQL-like syntax (schema-agnostic!)
	QueryTable(*TableQuery, grpc.ServerStreamingServer[TableQueryResponse]) error
	// Discover available tables
	ListTables(context.Context, *ListTablesRequest) (*ListTablesResponse, error)
	// Get table schema (for tools/debugging)
	DescribeTable(context.Context, *DescribeTableRequest) (*DescribeTableResponse, error)
	mustEmbedUnimplementedSystemTablePullServiceServer()
}

// UnimplementedSystemTablePullServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSystemTablePullServiceServer struct{}

func (UnimplementedSystemTablePullServiceServer) QueryTable(*TableQuery, grpc.ServerStreamingServer[TableQueryResponse]) error {
	return status.Error(codes.Unimplemented, "method QueryTable not implemented")
}
func (UnimplementedSystemTablePullServiceServer) ListTables(context.Context, *ListTablesRequest) (*ListTablesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTables not implemented")
}
func (UnimplementedSystemTablePullServiceServer) DescribeTable(context.Context, *DescribeTableRequest) (*DescribeTableResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DescribeTable not implemented")
}
func (UnimplementedSystemTablePullServiceServer) mustEmbedUnimplementedSystemTablePullServiceServer() {
}
func (UnimplementedSystemTablePullServiceServer) testEmbeddedByValue() {}

// UnsafeSystemTablePullServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemTablePullServiceServer will
// result in compilation errors.
type UnsafeSystemTablePullServiceServer interface {
	mustEmbedUnimplementedSystemTablePullServiceServer()
}

func RegisterSystemTablePullServiceServer(s grpc.ServiceRegistrar, srv SystemTablePullServiceServer) {
	// If the following call panics, it indicates UnimplementedSystemTablePullServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SystemTablePullService_ServiceDesc, srv)
}

func _SystemTablePullService_QueryTable_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TableQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SystemTablePullServiceServer).QueryTable(m, &grpc.GenericServerStream[TableQuery, TableQueryResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SystemTablePullService_QueryTableServer = grpc.ServerStreamingServer[TableQueryResponse]

func _SystemTablePullService_ListTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemTablePullServiceServer).ListTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemTablePullService_ListTables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemTablePullServiceServer).ListTables(ctx, req.(*ListTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemTablePullService_DescribeTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemTablePullServiceServer).DescribeTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemTablePullService_DescribeTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemTablePullServiceServer).DescribeTable(ctx, req.(*DescribeTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemTablePullService_ServiceDesc is the grpc.ServiceDesc for SystemTablePullService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemTablePullService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "systemtable.v1.SystemTablePullService",
	HandlerType: (*SystemTablePullServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListTables",
			Handler:    _SystemTablePullService_ListTables_Handler,
		},
		{
			MethodName: "DescribeTable",
			Handler:    _SystemTablePullService_DescribeTable_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueryTable",
			Handler:       _SystemTablePullService_QueryTable_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/v1/systemtable.proto",
}

const (
	StatementPushControl_RegisterPushTarget_FullMethodName   = "/systemtable.v1.StatementPushControl/RegisterPushTarget"
	StatementPushControl_UnregisterPushTarget_FullMethodName = "/systemtable.v1.StatementPushControl/UnregisterPushTarget"
	StatementPushControl_UpdatePushConfig_FullMethodName     = "/systemtable.v1.StatementPushControl/UpdatePushConfig"
)

// StatementPushControlClient is the client API for StatementPushControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============================================================================
// PUSH TARGET CONTROL SERVICE - Vector→TiDB registration
// ============================================================================
//
// This service enables Vector to proactively discover and register with TiDB,
// eliminating the need for TiDB to configure Vector's endpoint manually.
//
// Flow:
// 1. Vector discovers TiDB instances via PD
// 2. Vector calls RegisterPushTarget on each TiDB's status port
// 3. TiDB creates/updates its pusher with the provided endpoint and config
// 4. TiDB starts pushing statement data to Vector
type StatementPushControlClient interface {
	// Vector calls this to register itself as a push target for TiDB.
	// TiDB will create or update its pusher to send statements to Vector.
	RegisterPushTarget(ctx context.Context, in *RegisterPushTargetRequest, opts ...grpc.CallOption) (*RegisterPushTargetResponse, error)
	// Vector calls this to unregister (e.g., during shutdown).
	UnregisterPushTarget(ctx context.Context, in *UnregisterPushTargetRequest, opts ...grpc.CallOption) (*UnregisterPushTargetResponse, error)
	// Vector calls this to update configuration on registered TiDB instances.
	UpdatePushConfig(ctx context.Context, in *UpdatePushConfigRequest, opts ...grpc.CallOption) (*UpdatePushConfigResponse, error)
}

type statementPushControlClient struct {
	cc grpc.ClientConnInterface
}

func NewStatementPushControlClient(cc grpc.ClientConnInterface) StatementPushControlClient {
	return &statementPushControlClient{cc}
}

func (c *statementPushControlClient) RegisterPushTarget(ctx context.Context, in *RegisterPushTargetRequest, opts ...grpc.CallOption) (*RegisterPushTargetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterPushTargetResponse)
	err := c.cc.Invoke(ctx, StatementPushControl_RegisterPushTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statementPushControlClient) UnregisterPushTarget(ctx context.Context, in *UnregisterPushTargetRequest, opts ...grpc.CallOption) (*UnregisterPushTargetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterPushTargetResponse)
	err := c.cc.Invoke(ctx, StatementPushControl_UnregisterPushTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statementPushControlClient) UpdatePushConfig(ctx context.Context, in *UpdatePushConfigRequest, opts ...grpc.CallOption) (*UpdatePushConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePushConfigResponse)
	err := c.cc.Invoke(ctx, StatementPushControl_UpdatePushConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatementPushControlServer is the server API for StatementPushControl service.
// All implementations must embed UnimplementedStatementPushControlServer
// for forward compatibility.
//
// ============================================================================
// PUSH TARGET CONTROL SERVICE - Vector→TiDB registration
// ============================================================================
//
// This service enables Vector to proactively discover and register with TiDB,
// eliminating the need for TiDB to configure Vector's endpoint manually.
//
// Flow:
// 1. Vector discovers TiDB instances via PD
// 2. Vector calls RegisterPushTarget on each TiDB's status port
// 3. TiDB creates/updates its pusher with the provided endpoint and config
// 4. TiDB starts pushing statement data to Vector
type StatementPushControlServer interface {
	// Vector calls this to register itself as a push target for TiDB.
	// TiDB will create or update its pusher to send statements to Vector.
	RegisterPushTarget(context.Context, *RegisterPushTargetRequest) (*RegisterPushTargetResponse, error)
	// Vector calls this to unregister (e.g., during shutdown).
	UnregisterPushTarget(context.Context, *UnregisterPushTargetRequest) (*UnregisterPushTargetResponse, error)
	// Vector calls this to update configuration on registered TiDB instances.
	UpdatePushConfig(context.Context, *UpdatePushConfigRequest) (*UpdatePushConfigResponse, error)
	mustEmbedUnimplementedStatementPushControlServer()
}

// UnimplementedStatementPushControlServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStatementPushControlServer struct{}

func (UnimplementedStatementPushControlServer) RegisterPushTarget(context.Context, *RegisterPushTargetRequest) (*RegisterPushTargetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterPushTarget not implemented")
}
func (UnimplementedStatementPushControlServer) UnregisterPushTarget(context.Context, *UnregisterPushTargetRequest) (*UnregisterPushTargetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnregisterPushTarget not implemented")
}
func (UnimplementedStatementPushControlServer) UpdatePushConfig(context.Context, *UpdatePushConfigRequest) (*UpdatePushConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePushConfig not implemented")
}
func (UnimplementedStatementPushControlServer) mustEmbedUnimplementedStatementPushControlServer() {}
func (UnimplementedStatementPushControlServer) testEmbeddedByValue()                              {}

// UnsafeStatementPushControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatementPushControlServer will
// result in compilation errors.
type UnsafeStatementPushControlServer interface {
	mustEmbedUnimplementedStatementPushControlServer()
}

func RegisterStatementPushControlServer(s grpc.ServiceRegistrar, srv StatementPushControlServer) {
	// If the following call panics, it indicates UnimplementedStatementPushControlServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StatementPushControl_ServiceDesc, srv)
}

func _StatementPushControl_RegisterPushTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPushTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatementPushControlServer).RegisterPushTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatementPushControl_RegisterPushTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatementPushControlServer).RegisterPushTarget(ctx, req.(*RegisterPushTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatementPushControl_UnregisterPushTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterPushTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatementPushControlServer).UnregisterPushTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatementPushControl_UnregisterPushTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatementPushControlServer).UnregisterPushTarget(ctx, req.(*UnregisterPushTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatementPushControl_UpdatePushConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePushConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatementPushControlServer).UpdatePushConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StatementPushControl_UpdatePushConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatementPushControlServer).UpdatePushConfig(ctx, req.(*UpdatePushConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StatementPushControl_ServiceDesc is the grpc.ServiceDesc for StatementPushControl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StatementPushControl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "systemtable.v1.StatementPushControl",
	HandlerType: (*StatementPushControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterPushTarget",
			Handler:    _StatementPushControl_RegisterPushTarget_Handler,
		},
		{
			MethodName: "UnregisterPushTarget",
			Handler:    _StatementPushControl_UnregisterPushTarget_Handler,
		},
		{
			MethodName: "UpdatePushConfig",
			Handler:    _StatementPushControl_UpdatePushConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/v1/systemtable.proto",
}
